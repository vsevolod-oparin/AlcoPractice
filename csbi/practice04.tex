\section{\practicehead{Задачи по мотивам сортировки.}}

\begin{enumerate}

  \item (Easy) Дано число из $n$ цифр. Требуется переставить цифры так, чтобы
	\begin{itemize}
		\item результат был без ведущих нулей;
		\item результат был минимальным.
	\end{itemize}
	Решить за $O(n)$.

  \item (Easy) Дано число $n$. Требуется 
	\begin{itemize}
	  \item найти $\left\lfloor \sqrt{n} \right\rfloor$ используя бинарный поиск;
	  \item факторизовать $n$: представить в виде $n = \prod_{i} p_i^{\alpha_i}$, где
		все $p_i$~--- простые, а $\alpha_i$~--- положительные целые. Решить за $O(\sqrt{n})$.
    \end{itemize}

  \item (Easy) Дано $m$ контейнеров. В каждом контейнере присутствует 
	$v_i$ коробок с $b_i$ монетами. Требуется взять $N$ коробок, чтобы
	суммарное число монет в них было максимальным. Перекладывать монеты
	между коробками нельзя. Решить за $O(m \log m)$ при условии, что 
	стандартные арифметические операции с числами производятся за $O(1)$.

  \item (Medium) Дана дробь вида $\frac{\prod_{i=1}^n a_i}{\prod_{j=1}^m b_j}$.
	Известно, что $1 \leq a_i, b_j \leq 10^7$, $n, m \leq 10^5$. Требуется
	найти несократимую дробь, равную данной, и вернуть ее в таком же 
	формате как вход. Требуется найти решение, которое совершало бы 
	порядка $10^8$ операций.

  \item (Medium) Дано $2 \cdot n - 1$ коробок с черными и белыми шарами. 
	В $i$-ой коробке находится $w_i$ белых и $b_i$ черных шаров. Требуется
	выбрать $n$ коробок, чтобы суммарное число белых и черных шаров в 
	выбранных коробках было не меньше половины. Решить за $O(n \log n)$.

  \item (Medium) Последовательность $a_i$ длины $n$ записана слева направо.  
	Для каждого $a_i$ найдем самое правое $a_j$, меньшее $a_i$. Определим
	$r_i = j - i - 1$. Если такого $a_j$ нет, то $r_i = -1$. Требуется 
	посчитать по последовательности $a_i$ последовательность $r_i$ за $O(n \log n)$.

  \item (Hard)  Дан массив из $2 \cdot n - 1$ чисел. Разрешается хранить 
	$n$ элементов массива и небольшую константу памяти. Требуется найти 
	медиану за $O(n \log n)$.

  \item (Hard) Дана последовательность длины $n$. Найти максимальную возрастающую 
	подпоследовательность за $O(n \log n)$, не используя RMQ, set, map и 
	другие сложные структуры данных.

  \item (Hard) Куча хранится в массиве длины $n$. Родитель $p$ хранит детей
	в ячейках $2 \cdot p + 1$ и $2 \cdot p + 2$. Алгоритм приступает
	к сортировке. Сортировка устроена следующим образом. 
	\begin{itemize}
	  \item Поменять первый и последний элемент кучи местами.
	  \item Уменьшить размер кучи на единицу.
	  \item Запустить \texttt{heapifyDown} на первом элементе.
	\end{itemize}
	\texttt{heapifyDown} меняет родителя с наибольшим ребенком (при условии
    ,что ребенок больше родителя) и запускается рекурсивно.
	Сложность кучи определим через число вызовов функции \texttt{heapifyDown}.
	Требуется по $n$ построить самую сложную кучу. Ответ представить в виде
	перестановки из $n$ элементов. Решить за $O(n \log n)$.

\end{enumerate}
